<h1>Модуль 17. Шаблоны и паттерны. GoF, SOLID. Часть 1</h1>
<b>Основные принципы разработки:</b>
<br>
 <br>- <b>KISS («Keep it simple, stupid»)</b>. Данный принцип, сформулированный в ВМС США в 1960 году, гласит, что чем системы проще, тем стабильнее и надежнее они работают.
 <br>- <b>DRY («Don't repeat yourself»)</b>, по другой (более драматичной) версии — DIE («Duplication Is Evil»), не менее важен и формулируется как «не повторяйся». Сама концепция наследования в ООП изначально была призвана решить проблему повторяемости кода, и по возможности стоит использовать универсальные свойства и функции.
 <br>- <b>YAGNI («You Ain't Gonna Need It»</b> или «Вам это не понадобится»). Избыточный функционал нам не нужен, и при разработке стоит ограничиться необходимым минимумом, но при этом заложить возможность расширения системы и добавления в неё дополнительных функций.
<br><br>
<b>Виды паттернов:</b>
 <br>- Порождающие паттерны;
 <br>- Поведенческие паттерны;
 <br>- Структурные паттерны;
 <br>
<h2>Порождающие паттерны</h2>
Паттерны, которые позволяют реализовать более удобное и безопасное создание объектов в коде, называют порождающими.
<br>
<h2><b>Singleton</b></h2>
Применение паттерна Singleton имеет смысл, когда нам необходимо наличие только одного объекта определенного типа в коде. Реализация Singleton позволяет нам получить такой объект и точку доступа к нему. При этом создаётся он только тогда, когда необходим.
<br>
Таким образом, все реализации паттерна Singleton сводятся к тому, чтобы скрыть метод-конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл единственного нужного нам объекта при вызове из любой точки кода вашего приложения.
<br>
<h2><b>Abstract Factory</b></h2>
Паттерн Abstract Factory позволяет нам создавать группы связанных объектов без привязки к конкретным классам.
<br>
Применять стоит в следующих случаях:
 <br>- Ваша система не должна зависеть от способа компоновки объектов.
 <br>- Объекты в вашей системе должны использоваться вместе и быть взаимосвязанными.
Шаблон Abstract Factory также имеет и свои недостатки. К примеру, если мы решим добавить монстрам (пример AbstractFactoryRealExample) новый объект конфигурации (например, тип брони), то придётся переделывать и классы фабрик, и класс монстра. То есть данный паттерн, как и все, имеет свои ограничения.
<br>
<h2><b>Factory Method</b></h2>
Порождающий паттерн Factory Method даёт возможность определить некую универсальную конструкцию для создания объектов в основном классе. Далее в классах-наследниках будет приниматься решение о том, какой именно тип объекта будет создан.
Таким образом, предполагается, что основной класс делегирует создание объектов классам-наследникам.
<br>
Этот паттерн стоит применять в следующих случаях:
 <br>- Когда заранее неизвестен тип создаваемых объектов.
 <br>- Когда в системе нужно заранее предусмотреть независимость от процесса создания новых объектов и расширяемость. При этом легко можно будет добавлять поддержку создания объектов нового класса.
 <br>- Когда создание объектов необходимо делегировать от основного класса классам-наследникам.
<br>

Формально на языке С# реализация может выглядеть так:
```csharp
namespace FactoryMethodExample
{
   /// <summary>
   /// Базовый абстрактный класс
   /// </summary>
   abstract class BaseClass
   {}
 
   /// <summary>
   /// Конкретная реализация A
   /// </summary>
   class ConcreteClassA : BaseClass
   {}
 
   /// <summary>
   /// Конкретная реализация B
   /// </summary>
   class ConcreteClassB : BaseClass
   {}
 
   /// <summary>
   /// Абстрактный класс, от которого наследуются конкретные реализации
   /// </summary>
   abstract class Creator
   {
       /// Фабричный метод, который будет переопределен в классах-наследниках
       public abstract BaseClass FactoryMethod();
   }
 
   /// <summary>
   /// Конкретная реализация A
   /// </summary>
   class ConcreteCreatorA : Creator
   {
       //  Переопределенный Фабричный метод здесь возвращает конкретную реализацию
       public override BaseClass FactoryMethod()
       {
           return new ConcreteClassA();
       }
   }
   /// <summary>
   /// Конкретная реализация B
   /// </summary>
   class ConcreteCreatorB : Creator
   {
       //  Переопределенный Фабричный метод здесь возвращает конкретную реализацию
       public override BaseClass FactoryMethod()
       {
           return new ConcreteClassB();
       }
   }
```
Одна из возможных: вам нужно реализовать рассылку сообщений по SMS. Код написан, и всё у вас хорошо, но в коде жестко зашита рассылка именно посредством SMS.
Что будет, если вам нужно будет добавить рассылку по электронной почте? А если потом понадобится ещё и в мессенджеры? Вам придётся переписывать код заново, при этом он разрастется, и его будет неудобно поддерживать, он будет перегружен ветвлениями, блоками if-else и т.д., так вам нужно будет выполнять различные действия в зависимости от того, какой тип рассылки необходим.
Эту проблему успешно решает реализация Фабричного метода, который выносит привязку к конкретному способу отправки сообщений из вашего основного класса для рассылок.
(см. пример FactoryMethodRealExample)
<br>
<h2>Структурные паттерны</h2>
Структурные паттерны могут помочь в построении удобных в поддержке иерархий классов.
<br>
<h2><b>Adapter</b></h2>
Adapter - очень распространенный паттерн, позволяющий работать вместе объектам с несовместимыми интерфейсами.
<br>
Применение данного паттерна очень широко, так как в программировании очень часто необходимые нам ресурсы поддерживают разные способы доступа. И данные из этих ресурсов бывают нам нужны в нашем приложении одновременно.
<br>
Используется при:
 <br>- Когда необходимо использовать уже имеющийся класс, но его интерфейс не соответствует нашим потребностям.
 <br>- Когда нужно использовать существующий класс совместно с другими, интерфейсы которых не совместимы.
<br>

Абстрактный пример паттерна Adapter: 
```csharp
namespace AdapterExample
{
   // Наш код, где необходимо использование класса-источника
   class Client
   {
       public void Request(DataSource dataSource)
       {
           dataSource.GetData();
       }
   }
  
   /// <summary>
   /// Класс - источник ресурса, к которому нужно подключиться
   /// </summary>
   class DataSource
   {
       public virtual void GetData()
       {}
   }
  
   /// <summary>
   /// Класс - потребитель ресурса
   /// </summary>
   class DataConsumer
   {
       public void GetSpecificData()
       {}
   }
    /// <summary>
   /// Адаптер для подключения
   /// </summary>
   class Adapter : DataSource
   {
       private DataConsumer _dataConsumer = new DataConsumer();
      
       // метод для получения ресурса
       public override void GetData()
       {
           _dataConsumer.GetSpecificData();
       }
   }
}
```
<br>
<h2><b>Composite (Компоновщик)</b></h2>
Этот паттерн, позволяющий нам соединить группу объектов в древовидную структуру, а впоследствии работать с ними, как с единичным объектом.
<br>
Реализацию паттерна можно представить в виде любых объектов, которые соединены в древовидную структуру (то есть содержат подобъекты). В данном случае отлично подойдут, к примеру, пункты меню. Пункты могут содержать подпункты с подменю, и так далее.
<br>
Когда использовать:
 <br>- Тогда, когда объекты должны быть реализованы в виде иерархической древовидной структуры.
 <br>- Когда клиентский код должен одинаково управлять как целыми объектами, так и их составными частями, то есть и целый объект, и его структурные части должны реализовывать один и тот же интерфейс.
 <br>
<h2><b>Facade (Фасад)</b></h2>
Паттерн Facade скрывает сложность системы от клиентского кода с помощью предоставления универсального упрощенного интерфейса для взаимодействия с ней.
<br>
Когда использовать:
 <br>- Система сложна, необходимо упростить с ней работу. Фасад позволит определить одну упрощенную точку взаимодействия с ней.
 <br>- В коде может возникнуть слишком много зависимостей между клиентом и сложной системой. Реализация фасада позволит отделить (изолировать) части и компоненты сложной системы от клиента и работать с ними независимо.
 <br>- Если нам нужно определить подсистемы компонентов в сложной системе. Создание фасадов для компонентов каждой отдельной подсистемы упрощает взаимодействие между ними.
<br>
<h2>Поведенческие паттерны</h2>
Поведенческие паттерны обеспечивают эффективное и безопасное взаимодействие между объектами программы. В них, как правило, определяются алгоритмы взаимодействия.
<br>
 <br>- CHAIN OF RESPOSIBILITY -ЦЕПОЧКА ОБЯЗАННОСТЕЙ
 <br>- STATE - СОСТОЯНИЕ
 <br>- OBSERVER - НАБЛЮДАТЕЛЬ
 <br>
<h2><b>Chain of responsibility (Цепочка обязанностей)</b></h2>
Позволяет избежать жесткой привязки отправителя запроса к получателю.
<br>
Признаки того, что можно использовать цепочку:
 <br>- Имеется более одного объекта, который способен обрабатывать запрос.
 <br>- Нужно, чтобы запрос был обработан одни или несколькими объектами, но точно не определено, кем именно.
 <br>- Если динамически задаётся набор объектов.
 <br>

Формальный пример применения Цепочки обязанностей:
```csharp
 namespace ChainOfResponsibilityExample
{
   class Client
   {
       void Main()
       {
           // Первый обработчик
           Handler handlerOne = new HandlerOne();
          
           // Второй обработчик
           Handler handlerTwo = new HandlerTwo();
          
           // Передача запроса по цепочке и обработка
           handlerOne.Successor = handlerTwo;
           handlerOne.HandleRequest(2);
       }
   }
  
   /// <summary>
   /// Базовый интерфейс обработчика
   /// </summary>
   abstract class Handler
   {
       public Handler Successor { get; set; }
       public abstract void HandleRequest(int condition);
   }
   /// <summary>
   /// Реализация первого обработчика
   /// </summary>
   class HandlerOne : Handler
   {
       public override void HandleRequest(int condition)
       {
           if (condition==1)
           {
               // Завершение обработки при выполненном условии
           }
           else if (Successor != null)
           {
               // Условие не выполнено - передаем дальше по цепи
               Successor.HandleRequest(condition);
           }
       }
   }
   /// <summary>
   /// Реализация второго обработчика
   /// </summary>
   class HandlerTwo : Handler
   {
       public override void HandleRequest(int condition)
       {
           if (condition==2)
           {
               // Завершение обработки при выполненном условии
           }
           else if (Successor != null)
           {
               // Условие не выполнено - передаем дальше по цепи
               Successor.HandleRequest(condition);
           }
       }
   }
}
```
Здесь использование цепочки обязанностей дает нам такие преимущества: 
 <br>- Связи между объектами будут ослаблены. Отправитель и получатель запросов не знают друг о друге ничего. Клиенту же неизвестна цепочка объектов, какие объекты её составляют и как запрос в ней передаётся.
 <br>- Можно легко добавлять новые объекты, реализующие общий интерфейс.
<br>
В то же время у паттерна есть один недостаток: никто не гарантирует, что запрос будет обработан в итоге. Если необходимый обработчик не найден в цепочке, запрос просто покидает цепочку и остается необработанным.
<br>
<h2><b>State (Состояние)</b></h2>
При реализации паттерна State объекты получают возможность менять свое поведение в зависимости от внутреннего состояния.
<br>
Шаблон State используется:
 <br>- Когда поведение некоторых объектов в нашей программе может динамически изменяться в зависимости от состояния.
 <br>- Когда вы обнаружили в коде слишком много условных конструкций, которые обрабатывают различные состояния одного объекта.
<br>
<h2><b>Observer (Наблюдатель)</b></h2>
Суть паттерна Observer в том, что множество объектов могут быть потребителями информации из одного источника. В таком случае они как раз и являются наблюдателями, подписанными на этот один ресурс. При изменении наблюдаемого объекта автоматически происходит оповещение всех наблюдателей. 
<br>
Когда стоит использовать:
 <br>- Наша система содержит множество классов, причем состояние объектов должно быть синхронизировано.
 <br>- Если есть две стороны: одна из них рассылает сообщения и является главной, другая должна получать и реагировать. При этом логика разделена, а системы могут рассматриваться и использоваться независимо друг от друга.
 <br>- Если существует один объект-источник сообщений, а у него есть множество подписчиков. Количество последних при этом заранее неизвестно и может меняться в процессе работы программы.
<br>

Пример формального определения шаблона: 
```csharp
using System.Collections.Generic;
 
namespace ObserverExample
{
   /// <summary>
   /// Представляет объект - источник событий
   /// ( Иначе говоря, наблюдаемый объект )
   /// </summary>
   interface IPublisher
   {
       void AddSubscriber(ISubscriber sub);
       void RemoveSubscriber(ISubscriber o);
       void Publish();
   }
  
   /// <summary>
   /// Конкретная реализация источника событий
   /// ( наблюдаемого объекта )
   /// </summary>
   class ConcretePublisher : IPublisher
   {
       private List<ISubscriber> subscribers;
      
       public ConcretePublisher()
       {
           subscribers = new List<ISubscriber>();
       }
       public void AddSubscriber(ISubscriber sub)
       {
           subscribers.Add(sub);
       }
       public void RemoveSubscriber(ISubscriber o)
       {
           subscribers.Remove(o);
       }
       public void Publish()
       {
           foreach (ISubscriber subscriber in subscribers)
               subscriber.Update();
       }
   }
  
   /// <summary>
   /// Тот, кто подписан на события, наблюдаемого объекта
   /// ( иначе говоря, наблюдатель )
   /// </summary>
   interface ISubscriber
   {
       void Update();
   }
  
   /// <summary>
   /// Конкретная реализация наблюдателя
   /// </summary>
   class ConcreteSubscriber :ISubscriber
   {
       public void Update()
       {
       }
   }
}
```
<b>Обратите внимание,</b> что нашему объекту-источнику событий Publisher не надо ничего знать о наблюдателях-подписчиках Subscriber кроме того, что там реализован метод Update(). Эти объекты являются слабо связанными, изменения в одном не влияют на изменения в другом.
<br>
Наблюдатель-подписчик может прекратить наблюдение в любой момент. После этого оба объекта смогут продолжить существовать независимо друг от друга.
<br>
<h1>Принцип (концепция) SOLID</h1>
<b>S</b>ingle Responsibility Principle - ПРИНЦИП ЕДИНСТВЕННОЙ ОБЯЗАННОСТИ
<br>У класса должна быть только одна причина для изменения.
<br>Под обязанностью мы тут подразумеваем те функции, которые решает ваш класс, или задачу вашего класса.
<br>Суть в том, что задача у класса должна быть одна. Вы не должны пытаться добавить в ваш класс то, для чего он изначально не создавался просто потому, что так удобно. Лучше в этом случае создать отдельный класс.
<br>Если же вам понадобилось расширить функционал класса дополнительными функциями (но они всё равно выполняют ту цель, для которой класс создавался), то проблем нет, принцип в данном случае не нарушается.
<br>
<b>O</b>pen/Closed Principle - ПРИНЦИП ОТКРЫТОСТИ/ЗАКРЫТОСТИ
<br>Сущности программы должны быть открыты для расширения, но закрыты для модификации.
<br>Иначе говоря, вы должны проектировать классы так, чтобы при необходимости их можно было легко дополнить (то есть оставлять задел на будущее, возможности для масштабирования и роста функционала).
<br>При разработке стоит по возможности закладывать необходимый минимум функционала, и иметь в виду, что в дальнейшем он будет расширен, а то, что уже работает не сломается.
<br>
<b>L</b>iskov Substitution Principle - ПРИНЦИП ПОДСТАНОВКИ БАРБАРЫ ЛИСКОВ
<br>Цель в том, чтобы подклассы могли бы служить заменой своих базовых классов. При соблюдении этого принципа мы можем использовать классы-наследники вместо родительских классов, и работа программы не будет нарушена. 
<br>Если мы видим, что в коде идёт проверка на тип класса, то данный принцип нарушен. Код в этом случае стоит переписать так, чтобы не завязываться на конкретный тип.
<br>
<b>I</b>nterface Segregation Principle - ПРИНЦИП РАЗДЕЛЕНИЯ ИНТЕРФЕЙСОВ
<br>Рекомендуется по возможности создавать узко-специализированные интерфейсы, чтобы не тащить в классы излишний функционал, который, вероятнее всего, реализован не будет.
<br>Стоит по возможности разделять интерфейс класса на отдельные части. Позже вы сможете применять и изменять их независимо друг от друга. Следование этому принципу делает систему слабо связанной, и её проще поддерживать и обновлять.
<br>
<b>D</b>ependency Inversion Principle - ПРИНЦИП ИНВЕРСИИ ЗАВИСИМОСТЕЙ
<br>Объектом зависимости должна быть абстракция, а не что-то конкретное. 
<br>Абстракция (интерфейс — самый распространенный пример) не должна зависеть от деталей реализации. Наоборот, реализация должна зависеть от абстракции.
<br>
Эти принципы, по сути, не являются паттернами проектирования, это скорее концепции, применение которых в своих программах позволит вам как улучшить технический уровень кода, так и сделать возможной его поддержку другими разработчиками.



<b></b>
<b></b>
<b></b>